# Five commonly used algorithms

leetcode 经常会用到的五个算法。

[TOC]

## 分治法

把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

#### 适用特征

1. 该问题的规模缩小到一定的程度就可以容易地解决。
2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
3. 利用该问题分解出的子问题的解可以合并为该问题的解。
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

note:
若不具备`第3条`特征，可考虑采用[动态规划法（DP）](#动态规划（DP）)或者[贪心法](#贪心算法)。
若不具备`第4条`特征，可考虑采用动态规划法。

#### 解题步骤

1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。
3. 合并：将各个子问题的解合并为原问题的解。

#### 常见问题

1. 二分搜索
2. 大整数乘法
3. Strassen 矩阵乘法
4. 棋盘覆盖
5. 合并排序
6. 快速排序
7. 线性时间选择
8. 最接近点对问题
9. 循环赛日程表
10. 汉诺塔

## 动态规划（DP）

每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

#### 适用特征

能采用动态规划求解的问题的一般要具有 3 个性质：

1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。

#### 案例

有 n 级台阶，一个人每次上一级或者两级，问有多少种走完 n 级台阶的方法。
分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。在这个问题上，我们让 f(n)表示走上 n 级台阶的方法数。

那么当 n 为 1 时，f(n) = 1,n 为 2 时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，台阶有两级的时候，方法数为 2。那么当我们要走上 n 级台阶，必然是从 n-1 级台阶迈一步或者是从 n-2 级台阶迈两步，所以到达 n 级台阶的方法数必然是到达 n-1 级台阶的方法数加上到达 n-2 级台阶的方法数之和。即 f(n) = f(n-1)+f(n-2)，我们用 dp[n]来表示动态规划表，dp[i],i>0,i<=n,表示到达 i 级台阶的方法数。

## 贪心算法

在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。
贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

#### 解题步骤

将问题分解为若干个小问题，逐渐求得各个子问题的局部最优解，最后合并为原来问题的解。解题的一般步骤是：

1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的局部最优解合成原来问题的一个解。

#### 常见问题

1. Prim 算法（求最小生成树的）
2. Kruskal 算法（求最小生成树的）

#### 案例

钱币找零问题

这个问题在我们的日常生活中就更加普遍了。假设 1 元、2 元、5 元、10 元、20 元、50 元、100 元的纸币分别有 c0, c1, c2, c3, c4, c5, c6 张。现在要用这些钱来支付 K 元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将 Value 按照从小到大的顺序排好。

## 回溯法

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。深度优先；

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

回溯法是一种系统地搜索问题解答的方法。在搜索的过程中尝试找到问题的解，如果发现找不到了，就退一步，往上回溯（剪枝过程）。对于许多复杂问题和大规模问题都可以使用回溯法。
  回溯法的基本思想是按照深度优先搜索的策略，从根节点开始搜索，当到某个节点时要判断是否是包含问题的解，如果包含就从该节点继续搜索下去，如果不包含，就向父节点回溯。若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

回溯法常用的剪枝函数：(1)约束函数：在节点处减去不满足约束的子树。(2)界限函数：减去得不到最优解的子树。

#### 解题步骤

1. 针对所给问题，确定问题的解空间。
2. 利用适于搜索的方法组织解空间。
3. 利用深度优先搜索解空间。
4. 在搜索过程中用剪枝函数避免无效搜索。

#### 案例

举例：N 皇后问题

在一个 N\*N 的棋盘上放置 N 个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。

## 分支限界法

类似于回溯法，也是一种在问题的解空间树 T 上搜索问题解的算法。

note: 但在一般情况下，[分支限界法](#分支限界法)与[回溯法](#回溯法)的求解目标不同。[回溯法](#回溯法)的求解目标是找出 T 中满足约束条件的所有解，而[分支限界法](#分支限界法)的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。
